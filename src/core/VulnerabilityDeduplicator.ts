import { NormalizedVulnerability } from './VulnerabilityNormalizer';
import { Vulnerability } from '../types';

export interface DeduplicatedVulnerability extends NormalizedVulnerability {
  detectedByTools: string[];
  consensusScore: number;
  duplicateCount: number;
  mergedData: {
    descriptions: string[];
    recommendations: string[];
    confidenceScores: number[];
  };
}

export class VulnerabilityDeduplicator {
  private similarityThreshold: number;
  private locationTolerance: number;

  constructor(similarityThreshold: number = 0.8, locationTolerance: number = 5) {
    this.similarityThreshold = similarityThreshold;
    this.locationTolerance = locationTolerance;
  }

  deduplicateVulnerabilities(vulnerabilities: NormalizedVulnerability[]): DeduplicatedVulnerability[] {
    if (vulnerabilities.length === 0) {
      return [];
    }

    const groups = this.groupSimilarVulnerabilities(vulnerabilities);
    return groups.map(group => this.mergeVulnerabilityGroup(group));
  }

  private groupSimilarVulnerabilities(vulnerabilities: NormalizedVulnerability[]): NormalizedVulnerability[][] {
    const groups: NormalizedVulnerability[][] = [];
    const processed = new Set<number>();

    for (let i = 0; i < vulnerabilities.length; i++) {
      if (processed.has(i)) continue;

      const currentGroup = [vulnerabilities[i]];
      processed.add(i);

      // Find similar vulnerabilities
      for (let j = i + 1; j < vulnerabilities.length; j++) {
        if (processed.has(j)) continue;

        if (this.areSimilarVulnerabilities(vulnerabilities[i], vulnerabilities[j])) {
          currentGroup.push(vulnerabilities[j]);
          processed.add(j);
        }
      }

      groups.push(currentGroup);
    }

    return groups;
  }

  private areSimilarVulnerabilities(vuln1: NormalizedVulnerability, vuln2: NormalizedVulnerability): boolean {
    // Same vulnerability type
    if (vuln1.type !== vuln2.type) {
      return false;
    }

    // Same file
    if (vuln1.file !== vuln2.file) {
      return false;
    }

    // Similar line numbers (within tolerance)
    const lineDiff = Math.abs(vuln1.lineNumber - vuln2.lineNumber);
    if (lineDiff > this.locationTolerance) {
      return false;
    }

    // Similar descriptions (using text similarity)
    const descriptionSimilarity = this.calculateTextSimilarity(vuln1.description, vuln2.description);
    if (descriptionSimilarity < this.similarityThreshold) {
      return false;
    }

    return true;
  }

  private calculateTextSimilarity(text1: string, text2: string): number {
    // Simple Jaccard similarity based on words
    const words1 = new Set(text1.toLowerCase().split(/\s+/));
    const words2 = new Set(text2.toLowerCase().split(/\s+/));

    const intersection = new Set([...words1].filter(word => words2.has(word)));
    const union = new Set([...words1, ...words2]);

    return intersection.size / union.size;
  }

  private mergeVulnerabilityGroup(group: NormalizedVulnerability[]): DeduplicatedVulnerability {
    if (group.length === 1) {
      return {
        ...group[0],
        detectedByTools: [group[0].toolSource],
        consensusScore: group[0].confidence,
        duplicateCount: 1,
        mergedData: {
          descriptions: [group[0].description],
          recommendations: [group[0].recommendation],
          confidenceScores: [group[0].confidence]
        }
      };
    }

    // Use the vulnerability with highest confidence as the base
    const baseVulnerability = group.reduce((prev, current) => 
      current.confidence > prev.confidence ? current : prev
    );

    // Calculate consensus score based on number of tools and their confidence
    const consensusScore = this.calculateConsensusScore(group);

    // Merge descriptions and recommendations
    const uniqueDescriptions = [...new Set(group.map(v => v.description))];
    const uniqueRecommendations = [...new Set(group.map(v => v.recommendation))];
    const confidenceScores = group.map(v => v.confidence);
    const detectedByTools = [...new Set(group.map(v => v.toolSource))];

    // Use the highest severity found
    const maxSeverityScore = Math.max(...group.map(v => v.normalizedSeverity));
    const finalSeverity = this.mapScoreToSeverity(maxSeverityScore);

    return {
      ...baseVulnerability,
      severity: finalSeverity,
      normalizedSeverity: maxSeverityScore,
      confidence: consensusScore,
      description: this.mergeDescriptions(uniqueDescriptions),
      recommendation: this.mergeRecommendations(uniqueRecommendations),
      detectedByTools,
      consensusScore,
      duplicateCount: group.length,
      mergedData: {
        descriptions: uniqueDescriptions,
        recommendations: uniqueRecommendations,
        confidenceScores
      }
    };
  }

  private calculateConsensusScore(group: NormalizedVulnerability[]): number {
    // Base score from average confidence
    const avgConfidence = group.reduce((sum, v) => sum + v.confidence, 0) / group.length;
    
    // Bonus for multiple tool detection
    const toolBonus = Math.min(group.length * 0.1, 0.3); // Max 30% bonus
    
    // Bonus for severity consistency
    const severities = group.map(v => v.normalizedSeverity);
    const severityVariance = this.calculateVariance(severities);
    const consistencyBonus = severityVariance < 10 ? 0.1 : 0; // 10% bonus for consistent severity
    
    return Math.min(avgConfidence + toolBonus + consistencyBonus, 1.0);
  }

  private calculateVariance(numbers: number[]): number {
    const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
    const squaredDiffs = numbers.map(n => Math.pow(n - mean, 2));
    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;
  }

  private mapScoreToSeverity(score: number): 'Critical' | 'High' | 'Medium' | 'Low' {
    if (score >= 80) return 'Critical';
    if (score >= 60) return 'High';
    if (score >= 30) return 'Medium';
    return 'Low';
  }

  private mergeDescriptions(descriptions: string[]): string {
    if (descriptions.length === 1) {
      return descriptions[0];
    }

    // Use the longest description as primary, add others as context
    const primary = descriptions.reduce((prev, current) => 
      current.length > prev.length ? current : prev
    );

    const others = descriptions.filter(desc => desc !== primary);
    
    if (others.length === 0) {
      return primary;
    }

    return `${primary}\n\nAdditional context: ${others.join('; ')}`;
  }

  private mergeRecommendations(recommendations: string[]): string {
    if (recommendations.length === 1) {
      return recommendations[0];
    }

    // Combine unique recommendations
    const uniqueRecs = [...new Set(recommendations)];
    
    if (uniqueRecs.length === 1) {
      return uniqueRecs[0];
    }

    return uniqueRecs.map((rec, index) => `${index + 1}. ${rec}`).join('\n');
  }

  getDeduplicationStats(original: NormalizedVulnerability[], deduplicated: DeduplicatedVulnerability[]): {
    originalCount: number;
    deduplicatedCount: number;
    reductionPercentage: number;
    consensusFindings: number;
    multiToolFindings: number;
  } {
    const consensusFindings = deduplicated.filter(v => v.duplicateCount > 1).length;
    const multiToolFindings = deduplicated.filter(v => v.detectedByTools.length > 1).length;
    
    return {
      originalCount: original.length,
      deduplicatedCount: deduplicated.length,
      reductionPercentage: original.length > 0 ? ((original.length - deduplicated.length) / original.length) * 100 : 0,
      consensusFindings,
      multiToolFindings
    };
  }
}