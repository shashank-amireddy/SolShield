import { Vulnerability, ToolResult } from '../types';

export interface NormalizedVulnerability extends Vulnerability {
  normalizedSeverity: number; // 0-100 scale
  originalSeverity: string;
  originalToolSeverity: string;
  toolSpecificData: Record<string, any>;
}

export interface SeverityMapping {
  [toolName: string]: {
    [originalSeverity: string]: number;
  };
}

export class VulnerabilityNormalizer {
  private severityMappings: SeverityMapping;

  constructor() {
    this.severityMappings = this.initializeSeverityMappings();
  }

  normalizeVulnerabilities(toolResults: ToolResult[]): NormalizedVulnerability[] {
    const normalizedVulnerabilities: NormalizedVulnerability[] = [];

    for (const toolResult of toolResults) {
      for (const vulnerability of toolResult.vulnerabilities) {
        const normalized = this.normalizeVulnerability(vulnerability, toolResult.toolName);
        normalizedVulnerabilities.push(normalized);
      }
    }

    return normalizedVulnerabilities;
  }

  normalizeVulnerability(vulnerability: Vulnerability, toolName: string): NormalizedVulnerability {
    const normalizedSeverity = this.normalizeSeverity(vulnerability.severity, toolName);
    const standardSeverity = this.mapToStandardSeverity(normalizedSeverity);

    return {
      ...vulnerability,
      severity: standardSeverity,
      normalizedSeverity,
      originalSeverity: vulnerability.severity,
      originalToolSeverity: vulnerability.severity,
      toolSpecificData: {
        originalConfidence: vulnerability.confidence,
        originalDescription: vulnerability.description,
        originalRecommendation: vulnerability.recommendation
      }
    };
  }

  private initializeSeverityMappings(): SeverityMapping {
    return {
      'Slither': {
        'Critical': 95,
        'High': 80,
        'Medium': 60,
        'Low': 30,
        'Informational': 10
      },
      'Mythril': {
        'Critical': 90,
        'High': 75,
        'Medium': 55,
        'Low': 25
      },
      'SmartCheck': {
        'Critical': 85,
        'High': 70,
        'Medium': 50,
        'Low': 20
      },
      'Solhint': {
        'High': 65, // Solhint errors
        'Medium': 35, // Solhint warnings
        'Low': 15
      },
      'Securify2': {
        'Critical': 92,
        'High': 77,
        'Medium': 57,
        'Low': 27
      }
    };
  }

  private normalizeSeverity(severity: string, toolName: string): number {
    const toolMapping = this.severityMappings[toolName];
    
    if (!toolMapping) {
      // Default mapping for unknown tools
      return this.getDefaultSeverityScore(severity);
    }

    const normalizedScore = toolMapping[severity];
    if (normalizedScore !== undefined) {
      return normalizedScore;
    }

    // Fallback to default mapping
    return this.getDefaultSeverityScore(severity);
  }

  private getDefaultSeverityScore(severity: string): number {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 90;
      case 'high':
        return 70;
      case 'medium':
        return 50;
      case 'low':
        return 25;
      case 'informational':
      case 'info':
        return 10;
      default:
        return 50; // Default to medium
    }
  }

  private mapToStandardSeverity(normalizedScore: number): 'Critical' | 'High' | 'Medium' | 'Low' {
    if (normalizedScore >= 80) {
      return 'Critical';
    } else if (normalizedScore >= 60) {
      return 'High';
    } else if (normalizedScore >= 30) {
      return 'Medium';
    } else {
      return 'Low';
    }
  }

  getSeverityDistribution(vulnerabilities: NormalizedVulnerability[]): Record<string, number> {
    const distribution = {
      'Critical': 0,
      'High': 0,
      'Medium': 0,
      'Low': 0
    };

    for (const vuln of vulnerabilities) {
      distribution[vuln.severity]++;
    }

    return distribution;
  }

  getAverageConfidence(vulnerabilities: NormalizedVulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;
    
    const totalConfidence = vulnerabilities.reduce((sum, vuln) => sum + vuln.confidence, 0);
    return totalConfidence / vulnerabilities.length;
  }

  filterByMinimumSeverity(vulnerabilities: NormalizedVulnerability[], minSeverity: number): NormalizedVulnerability[] {
    return vulnerabilities.filter(vuln => vuln.normalizedSeverity >= minSeverity);
  }

  sortBySeverity(vulnerabilities: NormalizedVulnerability[]): NormalizedVulnerability[] {
    return vulnerabilities.sort((a, b) => b.normalizedSeverity - a.normalizedSeverity);
  }
}